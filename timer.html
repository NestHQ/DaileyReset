<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Daily Reset | 3-Minute Timer</title>
    <style>
      :root {
        --bg: #f3f5f9;
        --surface: #ffffff;
        --surface-soft: #f8faff;
        --text: #172235;
        --muted: #607089;
        --line: #d9e1ef;
        --primary: #2d62f2;
        --primary-soft: #dfe9ff;
        --success: #0f9d74;
        --danger: #d64545;
        --radius: 16px;
        --shadow: 0 14px 34px rgba(20, 40, 85, 0.11);
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        font-family: "Segoe UI", -apple-system, BlinkMacSystemFont, "Helvetica Neue", Arial, sans-serif;
        color: var(--text);
        background: radial-gradient(circle at 10% 0%, #ebf1ff 0%, transparent 35%),
          radial-gradient(circle at 90% 20%, #ecfbf7 0%, transparent 30%), var(--bg);
      }

      .container {
        width: min(700px, calc(100% - 28px));
        margin: 30px auto;
      }

      .panel {
        border: 1px solid var(--line);
        border-radius: 22px;
        background: var(--surface);
        box-shadow: var(--shadow);
        padding: 22px;
      }

      .topbar {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 10px;
        margin-bottom: 18px;
      }

      .brand {
        font-weight: 800;
        letter-spacing: 0.01em;
      }

      .user {
        color: var(--muted);
        font-size: 0.92rem;
      }

      .streak {
        margin: 8px 0 18px;
        display: inline-flex;
        align-items: center;
        gap: 8px;
        padding: 8px 12px;
        border: 1px solid var(--line);
        border-radius: 999px;
        background: var(--surface-soft);
        font-weight: 700;
      }

      .timer-wrap {
        display: grid;
        place-items: center;
        margin-bottom: 14px;
      }

      .timer-ring {
        --progress: 100;
        width: min(310px, 72vw);
        aspect-ratio: 1 / 1;
        border-radius: 50%;
        background: conic-gradient(var(--primary) calc(var(--progress) * 1%), #e5ecf8 0);
        display: grid;
        place-items: center;
        padding: 10px;
        transition: background 0.25s linear;
      }

      .timer-core {
        width: 100%;
        height: 100%;
        border-radius: 50%;
        border: 1px solid var(--line);
        background: #fff;
        display: grid;
        place-items: center;
        text-align: center;
      }

      .time {
        font-size: clamp(2.4rem, 10vw, 4.3rem);
        font-weight: 800;
        letter-spacing: 0.02em;
        line-height: 1;
      }

      .phase {
        margin-top: 10px;
        font-size: 0.94rem;
        font-weight: 600;
        color: var(--muted);
        transition: color 0.25s ease, transform 0.25s ease;
      }

      .phase.active {
        color: var(--primary);
        transform: translateY(-1px);
      }

      .timer-controls {
        margin: 14px 0 8px;
        display: grid;
        grid-template-columns: repeat(3, minmax(0, 1fr));
        gap: 10px;
      }

      .btn {
        border: 0;
        border-radius: var(--radius);
        padding: 11px 12px;
        cursor: pointer;
        font: inherit;
        font-weight: 700;
        text-decoration: none;
        display: inline-flex;
        justify-content: center;
        align-items: center;
        transition: 0.2s transform ease, 0.2s filter ease, 0.2s background-color ease;
      }

      .btn:hover {
        transform: translateY(-1px);
        filter: brightness(0.98);
      }

      .btn:disabled {
        cursor: not-allowed;
        opacity: 0.55;
        transform: none;
        filter: none;
      }

      .btn-primary {
        background: var(--primary);
        color: #fff;
      }

      .btn-secondary {
        background: #fff;
        color: var(--text);
        border: 1px solid var(--line);
      }

      .status {
        text-align: center;
        min-height: 1.4em;
        color: var(--muted);
        margin-bottom: 16px;
      }

      .status.complete {
        color: var(--success);
        font-weight: 700;
      }

      .tasks {
        border: 1px solid var(--line);
        border-radius: var(--radius);
        background: var(--surface-soft);
        padding: 14px;
        display: grid;
        gap: 10px;
      }

      .task {
        border: 1px solid #dfe6f3;
        border-radius: 12px;
        background: #fff;
        padding: 12px;
        transition: border-color 0.24s ease, background-color 0.24s ease;
      }

      .task.active {
        border-color: #b8cdfa;
        background: #f2f7ff;
      }

      .task h3 {
        margin: 0 0 6px;
        font-size: 0.98rem;
      }

      .task p {
        margin: 0;
        color: var(--muted);
        line-height: 1.5;
      }

      .input-card {
        margin-top: 14px;
        border: 1px solid var(--line);
        border-radius: var(--radius);
        background: #fff;
        padding: 14px;
      }

      label {
        display: block;
        margin: 10px 0 6px;
        font-weight: 700;
      }

      textarea,
      input {
        width: 100%;
        border: 1px solid var(--line);
        border-radius: 12px;
        padding: 10px 12px;
        font: inherit;
      }

      textarea {
        min-height: 115px;
        resize: vertical;
      }

      .save-btn {
        width: 100%;
        margin-top: 12px;
        padding: 12px 14px;
        font-weight: 800;
      }

      .save-status {
        margin-top: 10px;
        min-height: 1.2em;
        color: var(--muted);
      }

      .save-status.success {
        color: var(--success);
      }

      .save-status.error {
        color: var(--danger);
      }

      .footer-actions {
        margin-top: 14px;
        display: flex;
        justify-content: space-between;
        gap: 10px;
      }

      .flash {
        display: none;
        margin-bottom: 12px;
        padding: 10px 12px;
        border-radius: 12px;
        border: 1px solid #bce8d7;
        background: #eaf9f3;
        color: #0b6d4f;
      }

      .flash.show {
        display: block;
      }

      @media (max-width: 560px) {
        .footer-actions {
          flex-direction: column;
        }
      }
    </style>
  </head>
  <body>
    <main class="container">
      <section class="panel">
        <div class="topbar">
          <div>
            <div class="brand">Daily Reset</div>
            <div class="user" id="userEmail"></div>
          </div>
        </div>

        <div class="flash" id="flashMessage"></div>
        <p class="streak" id="streakLabel">ðŸ”¥ 0 Day Streak</p>
        <p class="user" id="planLabel">Plan: free</p>

        <div class="timer-wrap">
          <div class="timer-ring" id="timerRing" style="--progress: 100">
            <div class="timer-core">
              <p class="time" id="timerDisplay">03:00</p>
              <p class="phase" id="phaseLabel">Breathing</p>
            </div>
          </div>
        </div>

        <div class="timer-controls">
          <button type="button" class="btn btn-primary" id="startBtn">Start</button>
          <button type="button" class="btn btn-secondary" id="pauseBtn">Pause</button>
          <button type="button" class="btn btn-secondary" id="resetBtn">Reset</button>
        </div>

        <p class="status" id="sessionStatus">Press Start to begin.</p>

        <div class="tasks">
          <article class="task" data-phase="breathing">
            <h3>Step 1: Breathing</h3>
            <p>
              Focus on your breathing. Inhale slowly through your nose. Exhale gently through your mouth.
              Let your body settle. Let your mind slow down.
            </p>
          </article>
          <article class="task" data-phase="reflection">
            <h3>Step 2: Reflection</h3>
            <p>What is draining your energy right now? What is one small win from yesterday?</p>
          </article>
          <article class="task" data-phase="intention">
            <h3>Step 3: Intention</h3>
            <p>Write one clear intention for today. Make it specific. Make it meaningful.</p>
          </article>
        </div>

        <section class="input-card">
          <label for="reflectionInput">Reflection</label>
          <textarea id="reflectionInput" placeholder="Write your reflection..."></textarea>

          <label for="intentionInput">Intention</label>
          <input id="intentionInput" type="text" placeholder="Write one clear intention..." />

          <button type="button" class="btn btn-primary save-btn" id="saveBtn">Save & Complete Session</button>
          <p class="save-status" id="saveStatus"></p>
        </section>

        <div class="footer-actions">
          <a href="index.html" class="btn btn-secondary">Back to Home</a>
          <button type="button" class="btn btn-secondary" id="logoutBtn">Logout</button>
        </div>
      </section>
    </main>

    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script>
      const SUPABASE_URL = window.SUPABASE_URL || 'https://hleeqjvxcpeeilzwkrtg.supabase.co';
      const SUPABASE_ANON_KEY = window.SUPABASE_ANON_KEY || 'sb_publishable_c9MiudU-yQYoqV0ohnd9BA_164j8hGP';
      const supabase =
        window.supabase && typeof window.supabase.createClient === 'function'
          ? window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY)
          : null;

      window.completeReset = async function completeReset(points = 10) {
        if (!supabase) return { ok: false, reason: 'supabase_unavailable' };
        const {
          data: { user },
        } = await supabase.auth.getUser();

        if (!user) return { ok: false, reason: 'not_logged_in' };

        const { data: existing, error: selectError } = await supabase
          .from('leaderboard')
          .select('*')
          .eq('user_id', user.id)
          .maybeSingle();
        if (selectError) return { ok: false, reason: 'select_failed' };
        const today = new Date().toISOString().split('T')[0];

        if (existing) {
          let newStreak = Number(existing.streak) || 0;
          if (existing.last_reset_date !== today) {
            newStreak += 1;
          }

          const { error: updateError } = await supabase
            .from('leaderboard')
            .update({
              resets_completed: (existing.resets_completed || 0) + 1,
              focus_score: (existing.focus_score || 0) + points,
              streak: newStreak,
              last_reset_date: today,
            })
            .eq('user_id', user.id);
          if (updateError) return { ok: false, reason: 'update_failed' };
        } else {
          const { error: insertError } = await supabase.from('leaderboard').insert({
            user_id: user.id,
            name: user.email || 'Anonymous',
            email: user.email || '',
            resets_completed: 1,
            focus_score: points,
            streak: 1,
            last_reset_date: today,
          });
          if (insertError) return { ok: false, reason: 'insert_failed' };
        }

        return { ok: true };
      };

      window.saveReflection = async function saveReflection() {
        if (!supabase) {
          return { ok: false, reason: 'supabase_unavailable' };
        }
        const input = document.getElementById('reflectionInput');
        const text = input ? input.value.trim() : '';
        const {
          data: { user },
        } = await supabase.auth.getUser();

        if (!user) {
          alert('Login first');
          return { ok: false, reason: 'not_logged_in' };
        }

        const { error } = await supabase.from('reflections').insert({
          user_id: user.id,
          content: text,
        });

        if (error) {
          return { ok: false, reason: 'insert_failed' };
        }

        alert('Reflection saved âœ¨');
        return { ok: true };
      };
    </script>
    <script>
      (async () => {
        const FLASH_KEY = 'daily-reset-flash';
        const LOCAL_SESSION_KEY = 'daily-reset-local-session-email';
        const ENTRIES_KEY = 'daily-reset-entries';
        const STATS_KEY = 'daily-reset-user-stats';
        const LEADERBOARD_FLASH_KEY = 'daily-reset-leaderboard-flash';
        const TIMER_DURATION_MS = 3 * 60 * 1000;
        const reflectionPrompts = [
          "What is draining your energy right now?",
          "What is one small win from yesterday?",
          "What is something you're avoiding?",
          "What would make today meaningful?",
          "What is one thing you can let go of today?",
          "What are you grateful for right now?",
          "What habit would improve your life most?",
          "What is causing you stress right now?",
          "What is one boundary you need today?",
          "Where are you overcommitted?",
          "What thought is taking too much space?",
          "What is one priority that matters most today?",
          "What can you simplify in the next hour?",
          "What are you proud of from this week?",
          "What fear is slowing you down today?",
          "What support do you need right now?",
          "What does progress look like by tonight?",
          "What can wait until tomorrow?",
          "What is one kind thing you can do for yourself?",
          "What would your calmest self choose next?",
          "What are you holding onto that is not helping?",
          "What do you need less of today?",
        ];

        const isSupabaseConfigured = () =>
          Boolean(supabase) && Boolean(SUPABASE_URL && SUPABASE_ANON_KEY);

        let email = '';
        let userId = null;
        let supabaseMode = isSupabaseConfigured();

        if (supabaseMode) {
          const {
            data: { session },
          } = await supabase.auth.getSession();
          if (!session) {
            window.location.href = '/';
            return;
          }
          email = session.user?.email || 'user@example.com';
          userId = session.user?.id;
        } else {
          const localEmail = localStorage.getItem(LOCAL_SESSION_KEY);
          if (!localEmail) {
            window.location.href = 'index.html';
            return;
          }
          email = localEmail;
        }

        const emailEl = document.getElementById('userEmail');
        const timerDisplayEl = document.getElementById('timerDisplay');
        const timerRingEl = document.getElementById('timerRing');
        const phaseLabelEl = document.getElementById('phaseLabel');
        const streakLabelEl = document.getElementById('streakLabel');
        const planLabelEl = document.getElementById('planLabel');
        const reflectionPromptEl = document.querySelector('[data-phase="reflection"] p');
        const startBtn = document.getElementById('startBtn');
        const pauseBtn = document.getElementById('pauseBtn');
        const resetBtn = document.getElementById('resetBtn');
        const sessionStatusEl = document.getElementById('sessionStatus');
        const reflectionEl = document.getElementById('reflectionInput');
        const intentionEl = document.getElementById('intentionInput');
        const saveBtn = document.getElementById('saveBtn');
        const saveStatusEl = document.getElementById('saveStatus');
        const flashEl = document.getElementById('flashMessage');
        const logoutBtn = document.getElementById('logoutBtn');
        const taskEls = Array.from(document.querySelectorAll('.task'));

        emailEl.textContent = email;

        const flash = localStorage.getItem(FLASH_KEY);
        if (flash) {
          flashEl.textContent = flash;
          flashEl.classList.add('show');
          localStorage.removeItem(FLASH_KEY);
          setTimeout(() => {
            flashEl.classList.remove('show');
          }, 1800);
        }

        const getStats = () => JSON.parse(localStorage.getItem(STATS_KEY) || '{}');
        const setStats = (stats) => localStorage.setItem(STATS_KEY, JSON.stringify(stats));
        const getEntries = () => JSON.parse(localStorage.getItem(ENTRIES_KEY) || '{}');

        const getSubscriptionType = async () => {
          if (!supabaseMode) return 'free';
          if (!userId) return 'free';
          const { data } = await supabase
            .from('user_subscriptions')
            .select('subscription_type')
            .eq('user_id', userId)
            .maybeSingle();
          return data?.subscription_type || 'free';
        };

        const getDailyPrompt = () => {
          const now = new Date();
          const dayNumber = Math.floor(Date.UTC(now.getFullYear(), now.getMonth(), now.getDate()) / 86400000);
          const index = dayNumber % reflectionPrompts.length;
          return reflectionPrompts[index];
        };

        const formatTime = (ms) => {
          const safeMs = Math.max(0, ms);
          const totalSeconds = Math.ceil(safeMs / 1000);
          const minutes = Math.floor(totalSeconds / 60);
          const seconds = totalSeconds % 60;
          return `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
        };

        const getPhase = (remainingMs) => {
          const elapsed = TIMER_DURATION_MS - remainingMs;
          if (elapsed < 60000) return 'breathing';
          if (elapsed < 120000) return 'reflection';
          return 'intention';
        };

        const phaseLabel = (phase) => {
          if (phase === 'reflection') return 'Reflection';
          if (phase === 'intention') return 'Intention';
          return 'Breathing';
        };

        const timerStateKey = `daily-reset-timer-state-${email}`;
        let isRunning = false;
        let remainingTime = TIMER_DURATION_MS;
        let intervalId = null;
        let runStartTime = null;
        let runStartRemaining = TIMER_DURATION_MS;
        let isComplete = false;
        let savedCompletion = false;

        // Timer state
        const persistTimerState = () => {
          localStorage.setItem(
            timerStateKey,
            JSON.stringify({
              startTime: runStartTime,
              remainingTime,
              isRunning,
              isComplete,
              savedCompletion,
            })
          );
        };

        const updateStreakLabel = () => {
          const stats = getStats();
          const streak = stats[email]?.streak || 0;
          const unit = streak === 1 ? 'Day' : 'Days';
          streakLabelEl.textContent = `ðŸ”¥ ${streak} ${unit} Streak`;
        };

        const markActiveTask = (phase) => {
          taskEls.forEach((task) => {
            const active = task.dataset.phase === phase;
            task.classList.toggle('active', active);
          });
        };

        // Update display function
        const updateDisplay = () => {
          timerDisplayEl.textContent = formatTime(remainingTime);
          const progress = Math.max(0, Math.min(100, (remainingTime / TIMER_DURATION_MS) * 100));
          timerRingEl.style.setProperty('--progress', String(progress));

          const phase = getPhase(remainingTime);
          phaseLabelEl.textContent = phaseLabel(phase);
          phaseLabelEl.classList.toggle('active', isRunning && !isComplete);
          markActiveTask(phase);

          if (isComplete) {
            sessionStatusEl.textContent = 'Session Complete';
            sessionStatusEl.classList.add('complete');
            return;
          }

          if (isRunning) {
            sessionStatusEl.textContent = 'Session in progress...';
            sessionStatusEl.classList.remove('complete');
          } else {
            sessionStatusEl.textContent = 'Press Start to begin.';
            sessionStatusEl.classList.remove('complete');
          }
        };

        const updateButtons = () => {
          startBtn.disabled = isRunning || remainingTime <= 0;
          pauseBtn.disabled = !isRunning;
        };

        const clearTimerInterval = () => {
          if (intervalId !== null) {
            clearInterval(intervalId);
            intervalId = null;
          }
        };

        const completeSession = () => {
          clearTimerInterval();
          isRunning = false;
          isComplete = true;
          remainingTime = 0;
          runStartTime = null;
          runStartRemaining = 0;
          updateDisplay();
          updateButtons();
          persistTimerState();
        };

        // Start function
        const startTimer = () => {
          if (isRunning || remainingTime <= 0) return;
          clearTimerInterval();
          isRunning = true;
          runStartTime = Date.now();
          runStartRemaining = remainingTime;
          updateDisplay();
          updateButtons();
          persistTimerState();

          intervalId = setInterval(() => {
            const elapsed = Date.now() - runStartTime;
            remainingTime = Math.max(0, runStartRemaining - elapsed);
            if (remainingTime <= 0) {
              completeSession();
              return;
            }
            updateDisplay();
            persistTimerState();
          }, 250);
        };

        // Pause function
        const pauseTimer = () => {
          if (!isRunning) return;
          const elapsed = Date.now() - runStartTime;
          remainingTime = Math.max(0, runStartRemaining - elapsed);
          isRunning = false;
          runStartTime = null;
          clearTimerInterval();
          updateDisplay();
          updateButtons();
          persistTimerState();
        };

        // Reset function
        const resetTimer = () => {
          clearTimerInterval();
          isRunning = false;
          isComplete = false;
          savedCompletion = false;
          remainingTime = TIMER_DURATION_MS;
          runStartTime = null;
          runStartRemaining = TIMER_DURATION_MS;
          localStorage.removeItem(timerStateKey);
          saveStatusEl.textContent = '';
          saveStatusEl.className = 'save-status';
          updateDisplay();
          updateButtons();
        };

        const calculateRank = (targetEmail, nextStats) => {
          const emails = Array.from(new Set([...Object.keys(nextStats), targetEmail]));
          const ranked = emails
            .map((userEmail) => ({
              email: userEmail,
              streak: nextStats[userEmail]?.streak || 0,
              totalSessions: nextStats[userEmail]?.totalSessions || 0,
            }))
            .sort((a, b) => b.streak - a.streak || b.totalSessions - a.totalSessions || a.email.localeCompare(b.email));

          const position = ranked.findIndex((item) => item.email === targetEmail);
          return position >= 0 ? position + 1 : null;
        };

        const updateStatsAfterCompletion = () => {
          const stats = getStats();
          const current = stats[email] || { streak: 0, totalSessions: 0, lastCompletedDate: null };
          const today = new Date().toISOString().slice(0, 10);
          const yesterday = new Date(Date.now() - 86400000).toISOString().slice(0, 10);

          let nextStreak = 1;
          if (current.lastCompletedDate === today) {
            nextStreak = current.streak || 1;
          } else if (current.lastCompletedDate === yesterday) {
            nextStreak = (current.streak || 0) + 1;
          }

          const totalSessions = (current.totalSessions || 0) + 1;
          stats[email] = {
            streak: nextStreak,
            totalSessions,
            lastCompletedDate: today,
            updatedAt: Date.now(),
          };

          setStats(stats);
          updateStreakLabel();
          return { stats, streak: nextStreak };
        };

        // Restore session logic
        const restoreTimerState = () => {
          const saved = JSON.parse(localStorage.getItem(timerStateKey) || 'null');
          if (saved) {
            if (typeof saved.remainingTime === 'number') {
              remainingTime = Math.min(TIMER_DURATION_MS, Math.max(0, saved.remainingTime));
            }
            isComplete = Boolean(saved.isComplete) || remainingTime <= 0;
            savedCompletion = Boolean(saved.savedCompletion);

            const wasRunning = Boolean(saved.isRunning);
            const savedStart = typeof saved.startTime === 'number' ? saved.startTime : null;

            if (wasRunning && savedStart && !isComplete && remainingTime > 0) {
              const elapsed = Date.now() - savedStart;
              remainingTime = Math.max(0, remainingTime - elapsed);
              if (remainingTime <= 0) {
                completeSession();
              } else {
                startTimer();
              }
              updateDisplay();
              updateButtons();
              return;
            }

            isRunning = false;
            runStartTime = null;
            runStartRemaining = remainingTime;
            if (remainingTime <= 0) {
              isComplete = true;
            }
            persistTimerState();
          }

          updateDisplay();
          updateButtons();
        };

        const entries = getEntries();
        const lastEntry = entries[email]?.[0];
        if (lastEntry) {
          reflectionEl.value = lastEntry.reflection || '';
          intentionEl.value = lastEntry.intention || '';
        }

        saveBtn.addEventListener('click', async () => {
          saveStatusEl.className = 'save-status';
          if (!isComplete) {
            saveStatusEl.textContent = 'Finish the timer before completing your session.';
            saveStatusEl.classList.add('error');
            return;
          }

          if (savedCompletion) {
            window.location.href = 'leaderboard.html';
            return;
          }

          const reflection = reflectionEl.value.trim();
          const intention = intentionEl.value.trim();
          const allEntries = getEntries();
          const list = Array.isArray(allEntries[email]) ? allEntries[email] : [];
          list.unshift({ reflection, intention, createdAt: Date.now() });
          allEntries[email] = list.slice(0, 50);
          localStorage.setItem(ENTRIES_KEY, JSON.stringify(allEntries));

          const { stats, streak } = updateStatsAfterCompletion();
          const rank = calculateRank(email, stats);

          savedCompletion = true;
          persistTimerState();
          localStorage.setItem(
            LEADERBOARD_FLASH_KEY,
            `Session Complete! You are now ranked #${rank || '-'} globally. ðŸ”¥ Current Streak: ${streak} days`
          );

          saveStatusEl.textContent = 'Saved. Redirecting to leaderboard...';
          saveStatusEl.classList.add('success');

          try {
            if (window.completeReset) {
              await window.completeReset(10);
            }
            if (window.saveReflection) {
              await window.saveReflection();
            }
          } catch {}

          setTimeout(() => {
            window.location.href = 'leaderboard.html';
          }, 550);
        });
        window.__dailyResetSaveBound = true;

        startBtn.addEventListener('click', startTimer);
        pauseBtn.addEventListener('click', pauseTimer);
        resetBtn.addEventListener('click', resetTimer);
        window.__dailyResetTimerBound = true;

        logoutBtn.addEventListener('click', () => {
          logout();
        });

        async function logout() {
          if (supabaseMode) {
            await supabase.auth.signOut();
            window.location.href = '/';
            return;
          }
          localStorage.removeItem(LOCAL_SESSION_KEY);
          window.location.href = 'index.html';
        }

        reflectionPromptEl.textContent = getDailyPrompt();
        updateStreakLabel();
        const subscriptionType = await getSubscriptionType();
        const hasProAccess = subscriptionType === 'pro' || subscriptionType === 'team';
        planLabelEl.textContent = `Plan: ${subscriptionType}`;
        if (!hasProAccess) {
          phaseLabelEl.textContent = `${phaseLabelEl.textContent} Â· Free`;
        }
        restoreTimerState();
      })();
    </script>
    <script>
      (() => {
        if (window.__dailyResetTimerBound && window.__dailyResetSaveBound) return;

        const TIMER_DURATION_MS = 3 * 60 * 1000;
        const email = localStorage.getItem('daily-reset-local-session-email') || 'local-user';
        const timerStateKey = `daily-reset-timer-state-${email}`;
        const ENTRIES_KEY = 'daily-reset-entries';
        const STATS_KEY = 'daily-reset-user-stats';
        const LEADERBOARD_FLASH_KEY = 'daily-reset-leaderboard-flash';

        const timerDisplayEl = document.getElementById('timerDisplay');
        const sessionStatusEl = document.getElementById('sessionStatus');
        const timerRingEl = document.getElementById('timerRing');
        const startBtn = document.getElementById('startBtn');
        const pauseBtn = document.getElementById('pauseBtn');
        const resetBtn = document.getElementById('resetBtn');
        const saveBtn = document.getElementById('saveBtn');
        const saveStatusEl = document.getElementById('saveStatus');
        const reflectionEl = document.getElementById('reflectionInput');
        const intentionEl = document.getElementById('intentionInput');

        if (!timerDisplayEl || !sessionStatusEl || !startBtn || !pauseBtn || !resetBtn || !saveBtn) return;

        let isRunning = false;
        let remainingTime = TIMER_DURATION_MS;
        let intervalId = null;
        let startedAt = null;
        let startRemaining = TIMER_DURATION_MS;
        let isComplete = false;

        const format = (ms) => {
          const totalSeconds = Math.max(0, Math.ceil(ms / 1000));
          const minutes = Math.floor(totalSeconds / 60);
          const seconds = totalSeconds % 60;
          return `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
        };

        const persist = () => {
          try {
            localStorage.setItem(
              timerStateKey,
              JSON.stringify({ isRunning, remainingTime, startedAt, startRemaining, isComplete })
            );
          } catch {}
        };

        const load = () => {
          try {
            return JSON.parse(localStorage.getItem(timerStateKey) || 'null');
          } catch {
            return null;
          }
        };

        const updateButtons = () => {
          startBtn.disabled = isRunning || remainingTime <= 0;
          pauseBtn.disabled = !isRunning;
        };

        const updateDisplay = () => {
          timerDisplayEl.textContent = format(remainingTime);
          if (timerRingEl) {
            const pct = Math.max(0, Math.min(100, (remainingTime / TIMER_DURATION_MS) * 100));
            timerRingEl.style.setProperty('--progress', String(pct));
          }
          if (isComplete) {
            sessionStatusEl.textContent = 'Session Complete';
            sessionStatusEl.classList.add('complete');
          } else if (isRunning) {
            sessionStatusEl.textContent = 'Session in progress...';
            sessionStatusEl.classList.remove('complete');
          } else {
            sessionStatusEl.textContent = 'Press Start to begin.';
            sessionStatusEl.classList.remove('complete');
          }
          updateButtons();
        };

        const clearTick = () => {
          if (intervalId !== null) {
            clearInterval(intervalId);
            intervalId = null;
          }
        };

        const complete = () => {
          clearTick();
          isRunning = false;
          isComplete = true;
          remainingTime = 0;
          startedAt = null;
          updateDisplay();
          persist();
        };

        const tick = () => {
          if (!isRunning) return;
          const elapsed = Date.now() - startedAt;
          remainingTime = Math.max(0, startRemaining - elapsed);
          if (remainingTime <= 0) {
            complete();
            return;
          }
          updateDisplay();
          persist();
        };

        const start = () => {
          if (isRunning || remainingTime <= 0) return;
          isRunning = true;
          isComplete = false;
          startedAt = Date.now();
          startRemaining = remainingTime;
          clearTick();
          intervalId = setInterval(tick, 250);
          updateDisplay();
          persist();
        };

        const pause = () => {
          if (!isRunning) return;
          tick();
          isRunning = false;
          startedAt = null;
          clearTick();
          updateDisplay();
          persist();
        };

        const reset = () => {
          clearTick();
          isRunning = false;
          isComplete = false;
          remainingTime = TIMER_DURATION_MS;
          startedAt = null;
          startRemaining = TIMER_DURATION_MS;
          try {
            localStorage.removeItem(timerStateKey);
          } catch {}
          saveStatusEl.textContent = '';
          saveStatusEl.className = 'save-status';
          updateDisplay();
        };

        const saved = load();
        if (saved) {
          remainingTime = typeof saved.remainingTime === 'number' ? Math.max(0, Math.min(TIMER_DURATION_MS, saved.remainingTime)) : TIMER_DURATION_MS;
          isComplete = Boolean(saved.isComplete) || remainingTime <= 0;
          if (saved.isRunning && typeof saved.startedAt === 'number' && remainingTime > 0) {
            const elapsed = Date.now() - saved.startedAt;
            remainingTime = Math.max(0, remainingTime - elapsed);
            if (remainingTime <= 0) {
              complete();
            } else {
              start();
            }
          } else {
            isRunning = false;
            updateDisplay();
          }
        } else {
          updateDisplay();
        }

        startBtn.onclick = start;
        pauseBtn.onclick = pause;
        resetBtn.onclick = reset;
        saveBtn.onclick = async () => {
          saveStatusEl.className = 'save-status';
          if (!isComplete) {
            saveStatusEl.textContent = 'Finish the timer before completing your session.';
            saveStatusEl.classList.add('error');
            return;
          }
          const reflection = reflectionEl ? reflectionEl.value.trim() : '';
          const intention = intentionEl ? intentionEl.value.trim() : '';
          let entries = {};
          try {
            entries = JSON.parse(localStorage.getItem(ENTRIES_KEY) || '{}');
          } catch {
            entries = {};
          }
          const list = Array.isArray(entries[email]) ? entries[email] : [];
          list.unshift({ reflection, intention, createdAt: Date.now() });
          entries[email] = list.slice(0, 50);

          let stats = {};
          try {
            stats = JSON.parse(localStorage.getItem(STATS_KEY) || '{}');
          } catch {
            stats = {};
          }
          const current = stats[email] || { streak: 0, totalSessions: 0, lastCompletedDate: null };
          const today = new Date().toISOString().slice(0, 10);
          const yesterday = new Date(Date.now() - 86400000).toISOString().slice(0, 10);
          let nextStreak = 1;
          if (current.lastCompletedDate === today) {
            nextStreak = current.streak || 1;
          } else if (current.lastCompletedDate === yesterday) {
            nextStreak = (current.streak || 0) + 1;
          }
          stats[email] = {
            streak: nextStreak,
            totalSessions: (current.totalSessions || 0) + 1,
            lastCompletedDate: today,
            updatedAt: Date.now(),
          };

          try {
            localStorage.setItem(ENTRIES_KEY, JSON.stringify(entries));
            localStorage.setItem(STATS_KEY, JSON.stringify(stats));
            localStorage.setItem(
              LEADERBOARD_FLASH_KEY,
              `Session Complete! You are now ranked. ðŸ”¥ Current Streak: ${stats[email].streak} days`
            );
          } catch {}
          saveStatusEl.textContent = 'Saved. Redirecting to leaderboard...';
          saveStatusEl.classList.add('success');

          try {
            if (window.completeReset) {
              await window.completeReset(10);
            }
            if (window.saveReflection) {
              await window.saveReflection();
            }
          } catch {}

          setTimeout(() => {
            window.location.href = 'leaderboard.html';
          }, 500);
        };
      })();
    </script>
  </body>
</html>
